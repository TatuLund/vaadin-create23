# Project-Wide Copilot Instructions

## Tech stack
- Java 21
- Vaadin 8.30.0
- Hibernate ORM
- Redis event bus
- SLF4J for logging
- JSoup for HTML sanitization
- JUnit 4
- TestBench for end to end tests
- UI Unit Test framework
- OpenTelemetry for tracing and metrics
- SonarQube for code quality analysis
- JSpecify for nullness annotations
- Do not use Lombok
- Do not use Spring DI or other CDI frameworks

## Code Quality Standards
- Always use `@NullMarked` and `@Nullable` annotations
- Prefer records over classes for auxiliary data structures
- Use records for events posted to `EventBus`
- Use meaningful variable names (no single letters except for loops)
- Add comprehensive JavaDoc for public methods
- Use assert for parameter validation in private methods
- Use Objects.requireNonNull for parameter validation in public methods
- Avoid code duplication
- Avoid deep nesting of code blocks
- Keep utility methods in utility classes
- Keep classes focused on a single responsibility
- Define local classes for highly configured components
- Keep methods short and focused on a single task
- Use Vaadin Java coding conventions

## Architecture / Layering Guidelines
- Separate UI, business logic, and data access layers
- Views -> Presenters -> Services -> DAOs -> HibernateUtil
- Use singleton pattern for services

## Vaadin-Specific Rules
- Always extend `VaadinCreateView` for views
- Place CSS class name constants in `VaadinCreateTheme` class
- Implement accessibility with `AriaAttributes` and `AriaRoles`
- Avoid locking the UI thread for more than 300 ms
- Use `Utils.access()` for UI updates from background threads
- Place view specific components in the same package as the view
- Place general use components in components module
- Use Model View Presenter pattern when possible
- Use SASS for theming according to Vaadin conventions
- Use SASS mixins for each view

## Internationalization Guidelines
- Use HasI18N for components requiring localization
- Provide translations for all user-facing strings
- Place String constants of the translation keys in I18n.java
- Use message bundles for managing translations

## Testing Standards
- Use descriptive test method names: `should_DoSomething_When_Condition()`
- Mock external dependencies (Redis, Database) in backend module unit tests
- New business logic must have JUnit 4 tests
- New view components must have UI Unit Tests
- New custom components having client side code must have TestBench end to end tests
- Unit test class names should end with Test
- End to end test class names should end with IT
- Test both happy path and error conditions
- Verify accessibility features with Axe acceptance tests
- Verify theming with visual acceptance tests
- Tests need to pass to complete a change

## Performance Guidelines
- Use single-pass data processing where possible
- Implement proper connection pooling for external resources
- Cache expensive calculations

## Security Rules
- Always validate user inputs
- Sanitize user inputs with JSoup that are displayed to users using HTML content mode
- Use parameterized queries to prevent SQL injection
- Log security events appropriately
- Handle authentication failures gracefully
- Do not add dependencies with known security vulnerabilities
- Do not add dependencies when using them is not necessary, e.g. for a single utility method

## Logging Guidelines
- Use structured logging for all log messages
- Include user IDs and timestamps in log messages
- Avoid logging sensitive information
- Use appropriate log levels (DEBUG, INFO, WARN, ERROR)
- Use SLF4J for logging

## Backend-Specific Rules
- Use HibernateUtil in DAO classes for session and transaction management
- Use records for events posted to EventBus
- Implement equals and hashCode for entity classes based on id field
